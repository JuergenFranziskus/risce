section text


start:
    mov rsp, stack_start
    call zero_bss
    call prepare_divisors
    mov r16, 0
    mov r17, 1
.loop:
    add r18, r16, r17
    jb r18, r16, .end
    mov r1, r18
    call print_u32
    mov r16, r17
    mov r17, r18
    jmp .loop
.end:
    mov r1, goodbye_message
    call print_string
.halt:
    jmp .halt


zero_bss:
    lui r1, __bss_start@HIGH
    add r1, __bss_start@LOW
    lui r2, __bss_end@HIGH
    add r2, __bss_end@LOW
.loop:
    jnb r1, r2, .end
    store r0, byte [r1]
    add r1, 1
    jmp .loop
.end:
    ret


print_string:
    # Pointer to string is in r1, null-terminated
    mov r2, 0 # The byte index
.loop:
    add r4, r1, r2
    load r5, [r4]
    jeq r5, r0, .end
    store r5, byte [terminal]
    add r2, 1
    jmp .loop
.end:
    ret


print_u32:
    # Start of function, number to print is in r1
    enter r16, r17, r18, r31
    mov r16, r1 # The number that remains to be printed
    mov r17, divisors
    mov r18, 0 # Index into the divisor array
.loop:
    mov r1, 10
    jnb r18, r1, .end

    mov r1, r16
    load r2, [r17]
    call divmod # We now have the digit in r1, the remaining number in r2
    mov r16, r2
    add r1, 48 # Make ascii digit
    store r1, byte [terminal]
    add r17, 4
    add r18, 1
    jmp .loop
.end:
    mov r1, 10
    store r1, [terminal]
    leave r16, r17, r18, r31
    ret

prepare_divisors:
    mov r7, r31
    mov r4, divisors
    add r4, 9 * 4
    mov r5, 0
    mov r6, 1
.loop:
    mov r1, 10
    jnb r5, r1, .end
    
    store r6, [r4]
    sub r4, 4
    add r5, 1
    mov r1, r6
    call mul_ten
    mov r6, r1
    jmp .loop
.end:
    mov r31, r7
    ret


divmod:
    # Start of Function
    # The divident (remainder) is in r1
    # The divisor is in r2
    mov r3, 0 # The quotient is in r3
.loop:
    jb r1, r2, .end
    sub r1, r2
    add r3, 1
    jmp .loop
.end:
    mov r2, r1
    mov r1, r3
    ret

mul_ten:
    # Start of function, parameter is in r1
    shl r2, r1, 3 # Multiply parameter by 8
    shl r3, r1, 1 # Multiply parameter by 2
    add r1, r2, r3 # 2x + 8x = 10x
    ret


section data
goodbye_message db "All done ^^", 0

section bss
divisors resw 10


equ stack_start 0x10000 # The stack starts at the very end of ram
equ terminal -4 # The terminal is at the very last address
